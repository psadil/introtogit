---
title: "Intro to Git"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
library(tidyverse)
```

# What is `Git`? 

Git is a system for "version control". I don't have much nuance to add to this phrase, other than to highlight that, in the long run, it will be helpful to spend time thinking about what is meant by a "version" for reserach. For myself, I find that a "version" means a particular output: each pilot of an experiment, the code right before a meeting, all of your analysis right before a poster, the analyses immediately before a publication. For me, a version tends to mean the exact state of a project as a certain time, something that I'll want to be easily accessible. Your own definition of a version will probably change as you go through graduate school.

# Keep your goals in mind

The best backup and version control systems are the ones that you use continually. If you're satisfied with Box, Google Drive, USB drives, etc, then keep at it. I think that `Git` encourages good practices and so using it has the potential to make you a better researcher, teacher, writer. My goals are to 1) Show you how `Git` (with GitHub) can replace your current method 2) Overview a few ways in which it'll make you better.

As a side note, I think that starting and practicing `Git` carries another advantage. There are many tools, originally designed for software engineering, that are enormously helpful to researchers. These tools are integral to how research is becoming more reliant on software, more open, more collaborative. All of these tools are designed to work together. Using and learning `Git` is a step towards learning a whole ecosystem. If you haven't spent much time on the command line, `Git` will feel foreign, clunky, and hard. But the more that you become familiar with using tools like `Git`, the easier it will be to start learning these other tools.


# Installation (Windows-Specific)


1. [Install Notepad++](https://notepad-plus-plus.org/downloads/)
2. [Install Git](https://git-scm.com/download)

  - While installing `Git`, there will be a moment to select a default editor. Notepad++ is relatively easy to use. The rest of the defaults can be left as is.

You will be able to start `Git` by right-clicking a folder and then selecting "Git Bash Here".

# Configure git

`Git` is a system for doing version control, but it's designed to make collaborations central. For this reason, the versions you save will be associated with your name and email. This email will be the same email that you use to create a GitHub account. 

Start Git Bash and type the following. 

```{bash}
git config --global user.name "Your Name"
git config --global user.email email@gmail.com
```

The above pattern will start to be familiar. First comes the main command, `git`, followed by a subcommand (e.g., `config`). Then there will be a set of flags (`--global`), followed by arguments (e.g., `user.name "Patrick Sadil"`). The flags modify the subcommand, and the arguments are used while the subcommand is executed. This setup and terminology -- command, subcommand, flags, arguments -- is an example of the general knowledge you gain by working with `Git`. You will notice this pattern a lot with `Git`, and you will see it on many other command line tools.

To check elements of how `Git` is configured, type the following.

```{bash}
git config --list
```

Notice the pattern: you're again working with the config subcommand, but you're modifying what it does by using a different flag (`--list`). If you want to see all of the options for working with a subcommand, you can usually give the flag `--help`, as in

```{bash}
git config --help
```

The output will have a line for at least your `user.name` and `user.email`. You should also see a line for `core.editor`, which ought to point to notepad++. You can always change these configuration settings later. Setting the editor is a bit tricky, because you will need to get the quotations correct. The following command would work to setup your editor to be notepad++.

```{bash}
git config --global core.editor "'C:\Program Files\Notepad++\notepad++.exe' -multiInst -notabbar -nosession -noPlugin"
```

Once you've finished the configuration, close the terminal.

# Initialize a repository with `git init`

Make a new directory. Call it "demo". Start `Git` in that folder. The first step will be to 'initialize' `Git`. Here, to initialize is the verb used for associating `Git` with a particular folder.

```{bash, eval = FALSE}
git init
# Initialized empty Git repository in 
```

New terminology "repository", often shortened to "repo". A repository is a particular folder that is under version control by `Git`.

# Check new status with `git status`

```{bash, eval = FALSE}
git status
# On branch master
# No commits yet
# nothing to commit (create/copy files and use "git add" to track)
```

New words
- branch, and 'master'
- commit
- track

# Add data file

Working with fishes csv

Check out how the status has changed

```{bash, eval = FALSE}
git status
#On branch master

#No commits yet

#Untracked files:
#  (use "git add <file>..." to include in what will be committed)
#	data.csv
	
#nothing added to commit but untracked files present (use "git add" to track)
```

Git is aware that there is some file there, but that file is not yet 'tracked'.

# git add

```{bash, eval = FALSE}
git add fish.csv
git status
# On branch master

# No commits yet

# Changes to be committed:
#   (use "git rm --cached <file>..." to unstage)
#	new file:   data.csv
```

New words
- 'staged' this is something that Git is aware about, but has not yet committed to memory

# commit

```{bash, eval = FALSE}
git commit
#[master (root-commit) 3b1dd4b] Add initial data
# 1 file changed, 0 insertions(+), 0 deletions(-)
# create mode 100644 data.csv
git log
#commit 3b1dd4b34ff438234522df589c87222c8e49acdc (HEAD -> master)
#Author: Patrick Sadil <psadil@gmail.com>
#Date:   Wed Sep 30 14:53:17 2020 -0400
#    Add initial data
#    
#    Header should be an answer to "if applied, this commit will ..."
```


# tag

add another file

```{bash, eval = FALSE}
git add analysis.R
git commit -m "first analysis"
git tag -a oct-1-2020
# before meeting

# I'm going to talk about some cool plots
```

# checkout the past

```{bash}
touch analysis2.R
touch data.txt
# edit data
git add .
git commit -m "Prepare for new analyses"
git log --oneline
```

```{bash}
git checkout oct-1-2020
# take a look at the folder/data
```

```{bash}
git checkout master
```

# large files

produce figure

```{bash}
git lfs track "*.png"
```


# Ignore files

in .gitignore, add hippa folder

- https://rtyley.github.io/bfg-repo-cleaner/

# Interim

Take a step back. So far, we've started tracking files in a repository. This is 
okay. Think of this as a chain of snapshots, some of which you've decided to make
easily accessible (all states are accessible). 

- neat, since you've injected a bit of context into your code. 
 - As with many system of digital memory, the problem is rarely space; we can store 
 loads of data! 
 - Instead, we need good ways of indexing things. This process of committing different
 snapshots, labeling each of them with a context, will be your system of indexing.
 - I find it very helpful to create a tag before any meeting in which I'm going 
 to present a newish analysis, or beforea some version of a paper/poster.

- HOWEVER! Nothing has been backed up to the cloud! This is for github

# GitHub

create empty repository

```{bash}
git remote add origin git@github.com:psadil/tmp.git
git remote -v
git push -u --follow-tags origin master
git status
```

# README

add readme

These words will mix with github

```{bash}
git add README.md
git commit -m "Add readme"
git push
```


NOTE: This is a good time to talk about conventions. There's a sense in which nothing is 'special' about a readme file. But historically, careful programmers put readme files in their folders. Github latched on to that idea and made it easy to display that information. I think that's partly for socialogical reasons, as a study in how conventions become solidified into rules. But, it also highlights the importance of looking at other people's work. 

# Issues + branch

Create issue on github

Add a new Bayesian analysis.

Link to Stan website.

```{bash}
git checkout -b dev/bayes
touch R/model.stan
touch R/run-stan.R
git add .
git commit
# Add mixed effects model

# Closes #1
git push --set-upstream origin dev/bayes
```

 checkout on github

# merge branch into master

```{bash}
git checkout master
git merge dev/bayes
git push
```

# delete branch

branches and tags are very similar. 
- a tag is a snapshot that you always want to find easily

- a branch should be associated with a particular thing you're trying to do. 
 - A new analysis
 - fixing some bug
 - working on a new version of an experiment
 
That's why it's helpful to associate with an issue

A branch resolves an issue. When the issue is resolved, delete the branch

```{bash}
git branch -d dev/bayes
git push --delete origin dev/bayes
```

look around on github. see that the issue has been "closed"

NOTE! This only makes it harder to access the branch! The information is still stored. This is a general principle; deleting committed things is hard. This is both good and bad. On the good side, it means that past versions are usually safe. They'll be harder to access, but you can get to every snapshot. 

- on the bad side, if you accidentally commit sensitive information (e.g., hippa protected files, subject data), it's hard to rewrite history!

git bfg repo cleaner

https://rtyley.github.io/bfg-repo-cleaner/


Now we're starting to do something powerful, really launching off. I think one of the most interesting
things about Git is that it provides context for the different stages, and encourages you to focus on actionable goals. 

# Merge conflicts

```{bash}
git checkout -b edit-data
# edit
git add data
git commit -m "fix data file"
git checkout master
# edit data file here, too
git add data
git commit -m "fix data on master"
git merge edit-data
#Auto-merging data.csv
#CONFLICT (content): Merge conflict in data.csv
#Automatic merge failed; fix conflicts and then commit the result.
git status

git log --oneline --graph --all
# fix merge conflicts

```

# SSH keys


# Resources I consult regularly

- [Git Pro Book](https://git-scm.com/book/en/v2)
- Repositories of people I trust (e.g., [tidyverse packages](https://github.com/tidyverse))
